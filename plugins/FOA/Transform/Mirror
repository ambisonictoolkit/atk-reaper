/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: Mirror
  Mirror sound field across an arbitrary plane.
---------------------------------------------------------------------
*/

desc: ATK FOA Transform Mirror
// Mirror sound field across an arbitrary plane.


// Import library with shared functions, also imports cookdsp
import ../../libraries/atk/atk.jsfx-inc


in_pin:W
in_pin:X
in_pin:Y
in_pin:Z

out_pin:W
out_pin:X
out_pin:Y
out_pin:Z

slider1:0<180,-180,0.1>Azimuth (mouse)
slider2:0<-90,90,0.1>Elevation


/**********************************************************
Initialisation
**********************************************************/
@init

// Flag indicating that the plugin has not been fully mInitialised yet
mInitialised = 0;

mAzimuth   = 0;
mElevation = 0.;

// Setting memory locations for a number of 4x4 matrixes as 1D arrays
matrixRotate1   = 1000;
matrixTumble1   = 1020;
matrixTransform = 1040;
matrixTumble2   = 1060;
matrixRotate2   = 1080;

// These are used for matrix multiplications
matrixTemp1     = 1100;
matrixTemp2     = 1120;

// Resulting matrixes used for DSP processing
matrixDSP       = 1200;
matrixNewDSP    = 1220;
matrixInc       = 1240;

// Matrixes for graphic display of transformations
matrixDisplayPoints                    = 1300;
matrixDisplayNonTransformedInterpreted = 1400;
matrixDisplayTransformed               = 1500;
matrixDisplayTransformedInterpreted    = 1600;

// Matrixes for display of mirror plane
matrixMirrorNonRotated          = 1700;
matrixMirrorRotateted           = 1730;
matrixMirrorRotatedInterpreted  = 1760;

// Display points only needs to be generated once:
mNumDisplayedPoints = 24;
generateDisplaySignalMatrix(matrixDisplayPoints, mNumDisplayedPoints);

// We'll display non-transformed points as well, and hence they need to be interpreted.
interpreteProcessedPoints(matrixDisplayNonTransformedInterpreted, matrixDisplayPoints, mNumDisplayedPoints);

// Override gain for interpreted non-transformed points. This way they'll show up as blue.
i = 0;
loop(mNumDisplayedPoints,
  matrixDisplayNonTransformedInterpreted[mNumDisplayedPoints*3 + i] = -20.;
  i += 1;
);

// Six points on non-rotated mirror plane
matrixMirrorNonRotated[0]  = kInvSqrt2;
matrixMirrorNonRotated[6]  = cos($pi*0.25) * cos($pi*0.5);
matrixMirrorNonRotated[12] = cos($pi*0.25) * sin($pi*0.5);
matrixMirrorNonRotated[18] = sin($pi*0.25);

matrixMirrorNonRotated[1]  = kInvSqrt2;
matrixMirrorNonRotated[7]  = cos(-$pi*0.25) * cos($pi*0.5);
matrixMirrorNonRotated[13] = cos(-$pi*0.25) * sin($pi*0.5);
matrixMirrorNonRotated[19] = sin(-$pi*0.25);

matrixMirrorNonRotated[2]  = kInvSqrt2;
matrixMirrorNonRotated[8]  = cos(-$pi*0.25) * cos(-$pi*0.5);
matrixMirrorNonRotated[14] = cos(-$pi*0.25) * sin(-$pi*0.5);
matrixMirrorNonRotated[20] = sin(-$pi*0.25);

matrixMirrorNonRotated[3]  = kInvSqrt2;
matrixMirrorNonRotated[9]  = cos($pi*0.25) * cos(-$pi*0.5);
matrixMirrorNonRotated[15] = cos($pi*0.25) * sin(-$pi*0.5);
matrixMirrorNonRotated[21] = sin($pi*0.25);

matrixMirrorNonRotated[4]  = kInvSqrt2;
matrixMirrorNonRotated[10] = cos($pi*0.5);
matrixMirrorNonRotated[16] = sin($pi*0.5);
matrixMirrorNonRotated[22] = 0.;

matrixMirrorNonRotated[5]  = kInvSqrt2;
matrixMirrorNonRotated[11] = cos(-$pi*0.5);
matrixMirrorNonRotated[17] = sin(-$pi*0.5);
matrixMirrorNonRotated[23] = 0;

// Initiate graphics
gfx_ext_retina = 1;

// Initialisation of user interaction parameters
mPreviousMouseCap = 0;
mClickingAtCircle = 0;


function calculateMatrix()
(
  // Required for graphics
  mCosAzimuth   = cos(mAzimuth);
  mSinAzimuth   = sin(mAzimuth);

  mCosElevation = cos(mElevation);
  mSinElevation = sin(mElevation);
  
  // Generate matrixes
  generateRotationMatrix(matrixRotate1,-mAzimuth);
  generateTumblelMatrix(matrixTumble1, -mElevation);
  generateMirrorMatrix(matrixTransform);
  generateRotationMatrix(matrixRotate2, mAzimuth);
  generateTumblelMatrix(matrixTumble2,  mElevation);
  
  /* Build processing matrix by performing a series of matrix multiplications
                        result =         left X                   right             */
  matrixMultiplication  (matrixTemp1,    4, 4, matrixTumble1,     4, 4, matrixRotate1);
  matrixMultiplication  (matrixTemp2,    4, 4, matrixTransform,   4, 4, matrixTemp1);
  matrixMultiplication  (matrixTemp1,    4, 4, matrixTumble2,     4, 4, matrixTemp2);
  matrixMultiplication  (matrixNewDSP,   4, 4, matrixRotate2,     4, 4, matrixTemp1);
  
  // Transformation and interpretation of display points
  matrixMultiplication  (matrixDisplayTransformed, 4, 4, matrixNewDSP, 4, mNumDisplayedPoints, matrixDisplayPoints);
  interpreteProcessedPoints(matrixDisplayTransformedInterpreted, matrixDisplayTransformed, mNumDisplayedPoints);
  
  // Rotation and interpretation of mirror plane
  matrixMultiplication  (matrixTemp1,              4, 4, matrixRotate2, 4, 4, matrixTumble2);
  matrixMultiplication  (matrixMirrorRotateted,    4, 4, matrixTemp1,   4, 6, matrixMirrorNonRotated);
  interpreteProcessedPoints(matrixMirrorRotatedInterpreted, matrixMirrorRotateted, 6);
  
  // Set initial DSP processing coefficients if the plugin has not yet been mInitialised
  mInitialised == 0 ?
  (
    i = 0;
    loop(16,
      matrixDSP[i] = matrixNewDSP[i];
    );
    // Now we are fully mInitialised
    mInitialised = 1;
  );
);


/**********************************************************
Updated slider value:
**********************************************************/
@slider

mAzimuth         = slider1 * kDeg2Rad;
mElevation       = slider2 * kDeg2Rad;
calculateMatrix();


/**********************************************************
Graphics
**********************************************************/
@gfx 500 500


function setBeforeFontColor()
(
  gxColorSetHsl( 0.4, 60., 1., 0.5 );
);


function setBeforeColor()
(
  gxColorSetHsl( 0.15, 60., 1., 0.5 );
);


function setAfterColor()
(
  gxColorSetHsl( 1.0, 60., 1., 0.5 );
);


function setInteractionColor(anIsHighlighted)
(
  gxColorSetHsl( 1.0, 195., 1., 0.4 + 0.15 * anIsHighlighted );
);


function setInteractionColorWithDepth(aZpos, anIsHighlighted) local(lSaturation, lLightness)
(
  (aZpos < 0) ? (
    lSaturation = 1. - 0.4*aZpos;
    lLightness = 0.4;
  ) : (
    lSaturation = 1.;
    lLightness = 0.4 + 0.4*aZpos;
  );
  gxColorSetHsl( 1.0, 195., lSaturation, lLightness + 0.15*anIsHighlighted );
);


function postBefore()
(
  setBeforeFontColor();
  gxPositionSet( 20. * gfx_ext_retina, 20. );
  gfx_drawstr( "Before" );
);


function postMirror(anIsHighlighted)
(
  setInteractionColor(anIsHighlighted);
  gxPositionSet( 20 * gfx_ext_retina, 20. + 22. * gfx_ext_retina );
  gfx_drawstr( "Mirror" );
);


function postAfter()
(
  setAfterColor();
  gxPositionSet( 20. * gfx_ext_retina, 20. + 44. * gfx_ext_retina );
  gfx_drawstr( "After" );
);


// Set font
gfx_setfont(1, "Verdana", 16 * gfx_ext_retina );

determineGeometry();
drawBackgroundImage();

// Radius of interaction circle
kInteractionCircleRadius = 11. * gfx_ext_retina;


// Only update plugin parameters if the user click and drag interaction circle
mClickingAtCircle = clickingOnInteractionCircle(mPreviousMouseCap, mPosX, mPosY, mInteractionCircleRadius, mClickingAtCircle);
// Save current mouse_cap value in order to use in the above test at next iteration
mPreviousMouseCap = mouse_cap;

// Mouse interaction: Reset mAzimuth and transformAngle
(mClickingAtCircle) ? (
  mMouseX = mouse_x - gCenterX;
  mMouseY = mouse_y - gCenterY;
  
  // Update mAzimuth and slider2 and notify GUI of the change
  mAzimuth = atan2(-mMouseX, -mMouseY);
  slider1 = mAzimuth * kRad2Deg;
  slider_automate(slider1);
  
  calculateMatrix();
  
  mHiglightCircle = 1;
) : (
  mHiglightCircle = hoverOverInteractionCircle(mPosX, mPosY, mInteractionCircleRadius);
);

// Draw mirror plane
setInteractionColor(mHiglightCircle);

// Outline of mirror plane:
mPos1x = gCenterX - matrixMirrorRotatedInterpreted[ 6 ] * ( 1. + 0.2 * matrixMirrorRotatedInterpreted[ 12 ] ) * gRadius * kSqrt2;
mPos1y = gCenterY - matrixMirrorRotatedInterpreted[ 0 ] * ( 1. + 0.2 * matrixMirrorRotatedInterpreted[ 12 ] ) * gRadius * kSqrt2;

mPos2x = gCenterX - matrixMirrorRotatedInterpreted[ 7 ] * ( 1. + 0.2 * matrixMirrorRotatedInterpreted[ 13 ] ) * gRadius * kSqrt2;
mPos2y = gCenterY - matrixMirrorRotatedInterpreted[ 1 ] * ( 1. + 0.2 * matrixMirrorRotatedInterpreted[ 13 ] ) * gRadius * kSqrt2;

mPos3x = gCenterX - matrixMirrorRotatedInterpreted[ 8 ] * ( 1. + 0.2 * matrixMirrorRotatedInterpreted[ 14 ] ) * gRadius * kSqrt2;
mPos3y = gCenterY - matrixMirrorRotatedInterpreted[ 2 ] * ( 1. + 0.2 * matrixMirrorRotatedInterpreted[ 14 ] ) * gRadius * kSqrt2;

mPos4x = gCenterX - matrixMirrorRotatedInterpreted[ 9 ] * ( 1. + 0.2 * matrixMirrorRotatedInterpreted[ 15 ] ) * gRadius * kSqrt2;
mPos4y = gCenterY - matrixMirrorRotatedInterpreted[ 3 ] * ( 1. + 0.2 * matrixMirrorRotatedInterpreted[ 15 ] ) * gRadius * kSqrt2;

// Drawing twice to get thicker lines (as JS does not support adjustable line thickness)
drawQuadrangleOutline( mPos1x + 1.5, mPos1y + 1.5, mPos2x + 1.5, mPos2y + 1.5, mPos3x + 1.5, mPos3y + 1.5, mPos4x + 1.5, mPos4y + 1.5, 1. );
drawQuadrangleOutline( mPos1x + 1.0, mPos1y + 1.0, mPos2x + 1.0, mPos2y + 1.0, mPos3x + 1.0, mPos3y + 1.0, mPos4x + 1.0, mPos4y + 1.0, 1. );
drawQuadrangleOutline( mPos1x + 0.5, mPos1y + 0.5, mPos2x + 0.5, mPos2y + 0.5, mPos3x + 0.5, mPos3y + 0.5, mPos4x + 0.5, mPos4y + 0.5, 1. );
drawQuadrangleOutline( mPos1x      , mPos1y      , mPos2x      , mPos2y      , mPos3x      , mPos3y      , mPos4x      , mPos4y      , 1.);
drawQuadrangleOutline( mPos1x - 0.5, mPos1y - 0.5, mPos2x - 0.5, mPos2y - 0.5, mPos3x - 0.5, mPos3y - 0.5, mPos4x - 0.5, mPos4y - 0.5, 1. );
drawQuadrangleOutline( mPos1x - 1.0, mPos1y - 1.0, mPos2x - 1.0, mPos2y - 1.0, mPos3x - 1.0, mPos3y - 1.0, mPos4x - 1.0, mPos4y - 1.0, 1. );
drawQuadrangleOutline( mPos1x - 1.5, mPos1y - 1.5, mPos2x - 1.5, mPos2y - 1.5, mPos3x - 1.5, mPos3y - 1.5, mPos4x - 1.5, mPos4y - 1.5, 1. );

// Draw line at intersection between horisontal plane and mirror plane
mPos1x = gCenterX - matrixMirrorRotatedInterpreted[ 10 ] * gRadius;
mPos1y = gCenterY - matrixMirrorRotatedInterpreted[  4 ] * gRadius;

mPos2x = gCenterX - matrixMirrorRotatedInterpreted[ 11 ] * gRadius;
mPos2y = gCenterY - matrixMirrorRotatedInterpreted[  5 ] * gRadius;

// Drawing twice to get thicker lines (as JS does not support adjustable line thickness)
drawLineSegment( mPos1x + 1.5, mPos1y + 1.5, mPos2x + 1.5, mPos2y + 1.5, 1. );
drawLineSegment( mPos1x + 1.0, mPos1y + 1.0, mPos2x + 1.0, mPos2y + 1.0, 1. );
drawLineSegment( mPos1x + 0.5, mPos1y + 0.5, mPos2x + 0.5, mPos2y + 0.5, 1. );
drawLineSegment( mPos1x      , mPos1y      , mPos2x      , mPos2y      , 1. );
drawLineSegment( mPos1x - 0.5, mPos1y - 0.5, mPos2x - 0.5, mPos2y - 0.5, 1. );
drawLineSegment( mPos1x - 1.0, mPos1y - 1.0, mPos2x - 1.0, mPos2y - 1.0, 1. );
drawLineSegment( mPos1x - 1.5, mPos1y - 1.5, mPos2x - 1.5, mPos2y - 1.5, 1. );
postMirror(mHiglightCircle);

// Draw lines illustrating how each point has been mirrored
i = 0;
loop(mNumDisplayedPoints,
  mPos1x = gCenterX - gRadius * matrixDisplayNonTransformedInterpreted[ mNumDisplayedPoints + i ];
  mPos1y = gCenterY - gRadius * matrixDisplayNonTransformedInterpreted[ i ];
  mPos1z = matrixDisplayNonTransformedInterpreted[ 2 * mNumDisplayedPoints + i ];
  
  mPos3x = gCenterX - gRadius * matrixDisplayTransformedInterpreted[ mNumDisplayedPoints + i ];
  mPos3y = gCenterY - gRadius * matrixDisplayTransformedInterpreted[ i ];
  mPos3z = matrixDisplayTransformedInterpreted[ 2 * mNumDisplayedPoints + i ];
  
  mPos2x = ( mPos1x + mPos3x ) * 0.5;
  mPos2y = ( mPos1y + mPos3y ) * 0.5;
  mPos2z = ( mPos1z + mPos3z ) * 0.5;
  
  // Draw first part of line in "before" color
  setBeforeColor();
  
  // Drawing twice to get thicker lines (as JS does not support adjustable line thickness)
  drawLineSegment(mPos1x + 0.5, mPos1y + 0.5, mPos2x + 0.5, mPos2y + 0.5, 1. );
  drawLineSegment(mPos1x      , mPos1y      , mPos2x      , mPos2y      , 1. );
  drawLineSegment(mPos1x - 0.5, mPos1y - 0.5, mPos2x - 0.5, mPos2y - 0.5, 1. );
  
  // Draw small point where beam intersects mirror
  setInteractionColorWithDepth( mPos2z, mHiglightCircle );
  gfx_circle( mPos2x, mPos2y, ( 2.5 + 1.4 * mPos2z ) * gfx_ext_retina, 1 );
  
  // Draw second part of line
  // TODO: Optmise, with current use of colors there is no need to draw this as two sections
  setBeforeColor();
  
  // Drawing twice to get thicker lines (as JS does not support adjustable line thickness)
  drawLineSegment( mPos2x + 0.5, mPos2y + 0.5, mPos3x + 0.5, mPos3y + 0.5, 1. );
  drawLineSegment( mPos2x      , mPos2y      , mPos3x      , mPos3y      , 1. );
  drawLineSegment( mPos2x - 0.5, mPos2y - 0.5, mPos3x - 0.5, mPos3y - 0.5, 1. );
  
  i += 1;
);

// Draw non-transformed points:
setBeforeColor();
displayTransformedPointsWithCustomColor( matrixDisplayNonTransformedInterpreted, mNumDisplayedPoints );
postBefore();

// Draw points illustrating the effect of the transform
setAfterColor();
displayTransformedPoints( matrixDisplayTransformedInterpreted, mNumDisplayedPoints, 0 );
postAfter();

//setInteractionColor(0);
gxColorSetHsl(1.0, 195., 1., 0.4 + 0.15*mHiglightCircle);
mPosX = gCenterX - gRadius * slider4 * (mSinAzimuth * mCosElevation);
mPosY = gCenterY - gRadius * slider4 * (mCosAzimuth * mCosElevation);

// Drawing twice to get thicker lines (as JS does not support adjustable line thickness)
drawLineSegment( gCenterX + 1.5, gCenterY + 1.5, mPosX + 1.5, mPosY + 1.5, 1. );
drawLineSegment( gCenterX + 1.0, gCenterY + 1.0, mPosX + 1.0, mPosY + 1.0, 1. );
drawLineSegment( gCenterX + 0.5, gCenterY + 0.5, mPosX + 0.5, mPosY + 0.5, 1. );
drawLineSegment( gCenterX      , gCenterY      , mPosX      , mPosY      , 1. );
drawLineSegment( gCenterX - 0.5, gCenterY - 0.5, mPosX - 0.5, mPosY - 0.5, 1. );
drawLineSegment( gCenterX - 1.0, gCenterY - 1.0, mPosX - 1.0, mPosY - 1.0, 1. );
drawLineSegment( gCenterX - 1.5, gCenterY - 1.5, mPosX - 1.5, mPosY - 1.5, 1. );

// Draw circle for interaction, map vertical position to saturation, lightness and radius
(mSinElevation < 0) ? (
  mSaturation = 1. - 0.25*mSinElevation;
  mLightness = 0.4;
) : (
  mSaturation = 1.;
  mLightness = 0.4 + 0.25*mSinElevation;
);
gxColorSetHsl(1.0, 195., mSaturation, mLightness + 0.15*mHiglightCircle);

mInteractionCircleRadius = 4. * mSinElevation + kInteractionCircleRadius;
drawInteractionCircle(mPosX, mPosY, mInteractionCircleRadius);


/**********************************************************
Preprocessing prior to audio vector processing.
**********************************************************/
@block

mInverseSamplesblock = 1. / samplesblock;

// Counter is called "ii" rather than "i" in order to ensure that we do not use the same counter here as in other sections
ii = 0;
loop(16,
  matrixInc[ii] = ( matrixNewDSP[ ii ] - matrixDSP[ ii ] ) * mInverseSamplesblock;
  ii += 1;
);


/**********************************************************
Calculate audio sample
**********************************************************/
@sample

ii = 0;
loop(16,
  matrixDSP[ii] += matrixInc[ii];
  ii += 1;
);

wIn = spl0;
xIn = spl1;
yIn = spl2;
zIn = spl3;

// Some transforms blow up if track is 2 channels only as spl2 and spl3 might be un-ininitiated.
(num_ch == 2) ? (
  yIn = 0.;
  zIn = 0.;
);

// Matrix multiplication with input signal:
spl0 = wIn * matrixDSP[0] + xIn  * matrixDSP[1]  + yIn * matrixDSP[2]  + zIn * matrixDSP[3];
spl1 = wIn * matrixDSP[4] + xIn  * matrixDSP[5]  + yIn * matrixDSP[6]  + zIn * matrixDSP[7];
spl2 = wIn * matrixDSP[8] + xIn  * matrixDSP[9]  + yIn * matrixDSP[10] + zIn * matrixDSP[11];
spl3 = wIn * matrixDSP[12] + xIn * matrixDSP[13] + yIn * matrixDSP[14] + zIn * matrixDSP[15];
