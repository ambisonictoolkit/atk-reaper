/*
Copyright the ATK Community and Joseph Anderson, Josh Parmenter, Trond Lossius, 2013

               J Anderson     j.anderson[at]ambisonictoolkit.net
               J Parmenter    j.parmenter[at]ambisonictoolkit.net
               T Lossius      trond.lossius[at]bek.no


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
and GNU General Public License along with this program.  If not, see
<http://www.gnu.org/licenses/>.


---------------------------------------------------------------------
  Class: mono
  A Matrix decoder synthesising a single microphone
  
---------------------------------------------------------------------
*/

desc: ATK FOA Decode Mono
// Mono decoder - synthesises a single microphone


// Import library with shared functions, also imports cookdsp
import ../../libraries/atk/atk.jsfx-inc


in_pin:W
in_pin:X
in_pin:Y
in_pin:Z

out_pin:L
out_pin:R


slider1:0<180,-180,1>Azimuth
slider2:0<-90,90,1>Elevation
slider3:0.5<0,1.,0.01>Mic pattern (Omni - Cardoid - Figure 8)
slider4:0<0,1,1{Left channel only, Left and right channel}>Returned signal


options:no_meter


/**********************************************************
Initialisation
**********************************************************/
@init

// Setting memory locations for 4x4 matrix as 1D array
mIsInitialised = 0;

// Graphics
gfx_ext_retina = 1;

// Prevent auto clear of each frame
gfx_clear = -1;

// Initialisation of user interaction parameters
mPreviousMouseCap = 0;
mClickingAtCircle = 0;


/**********************************************************
Updated slider value:
**********************************************************/
@slider

mAzimuth        = slider1 * kDeg2Rad;
mElevation        = slider2 * kDeg2Rad;
mPattern = slider3;
mReturnMode = slider4;


mNewW = ( 1. - mPattern ) * sqrt( 2. );
mNewX = mPattern * cos( mAzimuth ) * cos( mElevation );
mNewY = mPattern * sin( mAzimuth ) * cos( mElevation );
mNewZ = mPattern * sin( mElevation );

(mIsInitialised == 0) ?
(
  mW = mNewW;
  mX = mNewX;
  mY = mNewY;
  mZ = mNewZ;
  mIsInitialised = 1;
);


/**********************************************************
Graphics
**********************************************************/
@gfx 500 500

function plotPattern( anAngle ) // local (lAngle)
(
  lRadius = ( ( 1.0 - mPattern ) + ( mPattern * cos( anAngle - mAzimuth ) * cos( mElevation) ) ) * gRadius;
  
  ( lRadius < 0 ) ? (
    lRadius = -lRadius;
    gxColorSetHsl(1.0, 30., 1., 0.5);
  ) : (
    gxColorSetHsl(1.0, 60., 1., 0.5);
  );
  
  mPlotPatternX = gCenterX - lRadius * sin( anAngle );
  mPlotPatternY = gCenterY - lRadius * cos( anAngle );
);


// Test if track has sufficient number of channels
mChannelWarning = testNumChannels( 4 );

determineGeometry();

// Reset azimuth and spread on mouse click
mouse_cap == 1 ?
(
  mMouseX = mouse_x - gCenterX;
  mMouseY = mouse_y - gCenterY;
  mAzimuth = atan2(-mMouseX, -mMouseY);
  slider1 = mAzimuth * kRad2Deg;
  
  // Notify GUI that azimuth has changed, and update coefficients
  slider_automate(slider1);
  
  mHiglightCircle = 1;
) : (
  // Check hover relative to most recently drawn position
  mHiglightCircle = hoverOverInteractionCircle( mPosX, mPosY, mInteractionCircleRadius );
);

// Only refresh GUI when needed
( geometryHasChanged( mPrevWidth, mPrevHeight ) || ( slider1 != mPrevSlider1 ) || ( slider2 != mPrevSlider2 ) || ( slider3 != mPrevSlider3 ) || ( mChannelWarning != mPrevChannelWarning ) ) ? (
  
  drawBackgroundImage( 2 );
  drawFuMa();
  
  // Force redraw of interaction circle
  mPrevHHiglightCircle = -1;

  // Draw microphone pattern
  i = 1;
  plotPattern( kDeg2Rad * i );
  gfx_x = mPlotPatternX;
  gfx_y = mPlotPatternY;

  loop( 360,
    i += 1;
    plotPattern( kDeg2Rad * i );
    gfx_lineto( mPlotPatternX, mPlotPatternY, 1.0 ); 
  );
  
  // Draw channel warning if needed
  mChannelWarning ? drawChannelWarning( 4 );
  
  mPrevWidth          = gfx_w;
  mPrevHeight         = gfx_h;
  mPrevSlider1        = slider1;
  mPrevSlider2        = slider2;
  mPrevSlider3        = slider3;
  mPrevChannelWarning = mChannelWarning;
);

// Redraw interaction circle when needed - avoid if channel warning
( ( mHiglightCircle != mPrevHHiglightCircle ) && !mChannelWarning ) ? (
  
  // Draw circle for interaction, map vertical position to saturation, lightness and radius
  mCosAzi  = cos(mAzimuth);
  mSinAzi  = sin(mAzimuth);
  mCosEle  = cos(mElevation);
  mSinEle  = sin(mElevation);
  
  // Color depends on elevation, mouseClick and mouseHover
  (mSinEle < 0) ? (
    mSaturation = 1. - 0.25*mSinEle;
    mLightness = 0.4;
  ) : (
    mSaturation = 1.;
    mLightness = 0.4 + 0.25*mSinEle;
  );
  gxColorSetHsl( 1.0, 195., mSaturation, mLightness + 0.15 * mHiglightCircle );
  
  // Position and radius depends on elevation
  mPosX = gCenterX - gRadius * (mSinAzi * mCosEle);
  mPosY = gCenterY - gRadius * (mCosAzi * mCosEle);
  mInteractionCircleRadius = radiusWthElevation( gInteractionCircleRadius, mElevationvation );
  
  // Draw line from centre to interaciton circle
  drawLineSegment(gCenterX, gCenterY, mPosX, mPosY, 1);
  
  drawInteractionCircle(mPosX, mPosY, mInteractionCircleRadius);
  
  mPrevHHiglightCircle = mHiglightCircle;
);



/**********************************************************
Preprocessing prior to audio vector processing.
**********************************************************/
@block

mInverseSamplesblock = 1. / samplesblock;

// Counter is called "ii" rather than "i" in order to ensure that we do not use the same counter here as in other sections

mIncW = ( mNewW - mW ) * mInverseSamplesblock;
mIncX = ( mNewX - mX ) * mInverseSamplesblock;
mIncY = ( mNewY - mY ) * mInverseSamplesblock;
mIncZ = ( mNewZ - mZ ) * mInverseSamplesblock;


/**********************************************************
Calculate audio sample
**********************************************************/
@sample

wIn = spl0;
xIn = spl1;
yIn = spl2;
zIn = spl3;


// Prevent potential blow up if track is 2 channels only and spl2 and spl3 are un-ininitiated.
(num_ch == 2) ? (
  yIn = 0.;
  zIn = 0.;
);

// Linear interpolation to new coefficients:
mW += mIncW;
mX += mIncX;
mY += mIncY;
mZ += mIncZ;

spl0 = wIn * mW  + xIn * mX  + yIn * mY  + zIn * mZ;
spl1 = spl0 * mReturnMode;
// Channel 3 and 4 need to be silenced to prevent signals from leaking through
spl2 = 0.;
spl3 = 0.;
